# 类于面向对象

## 对象比较：is与==

+ == 运算符比较的是相等性，是他们的内容是否相等
+ is 比较的是相同性，及在内存中是否是同一对象

或者可以这样描述：

+ 当两个变量指向同一个对象时，is表达式的结果为True
+ 当各种变量指向对象的内容相同时，== 表达式的结果为True

## 类的字符串表示：__str__ 和 __repr__

使用`__str__`和`__repr__`都可以控制类的字符串表示。关于二者的区别：

+ `__str__` 的返回结果应该是可读的，尽量简洁，会在`print()`和`str()`函数时调用
+ `__repr__`的返回结果应该时无歧义的，有助于调试（甚至是使用返回的字符串重建类的对象），在python解释器中调用对象时会调用该函数，并且如果没有定义`__str__`函数则会默认退回成`__repr__`函数

（eg：日期类）

## easier to ask for forgiveness than permission，编写自己的异常类

关于“请求宽恕比请求许可更容易”这一思想我理解的也不是很深，参考一篇帖子：https://www.codenong.com/12265451/

大概的理解就是，编写代码时，尽量让他人知道怎么处理错误，而不是让他人判断错误。

在自己编写一些模块代码时，我们应该秉承这样的风格：

```python
class BaseError(ValueError):
    pass

class MyError1(BaseError):
    pass

class MyError2(BaseError):
    pass
```

这样做的好处是，自己可以清晰的捕捉自己编写的代码中的一场，同时如果想一同处理自己编写的异常，可以直接捕捉`BaseError`，而不会影响他人捕捉异常。

```python
try:
    pass
except MyError2 as e:
    # 处理异常
```

## python中的拷贝：copy和deepcopy

python中的拷贝在`copy`模块中实现，浅拷贝为`copy()`，深拷贝为`deepcopy()`，
源码地址：https://docs.python.org/3/library/copy.html?highlight=copy#module-copy

关于深拷贝和浅拷贝之间的区别：对于复合对象（类和列表、字典等）：

+ 浅拷贝只是复制一份引用，如果原始对象被修改，那么拷贝对象也会被修改
+ 深拷贝则会新建一份对象，修改原始对象无影响
